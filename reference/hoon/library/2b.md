chapter 2b, basic containers

Section 2bA, units                    

###++biff 

Gate to unit.
```
++  biff                                                ::  apply
  |*  [a=(unit) b=$+(* (unit))]
  ?~  a  ~
  (b u.a)
::
```

Applies a gate that produces a unit to the value of a unit. If the unit is empty, `~` is produced.

`a`
A unit.

`b`
A gate that accepts a noun and produces a unit.

        ~zod/try=> (biff (some 5) |=(a=@ (some (add a 2))))
        [~ u=7]
        ~zod/try=> (biff ~ |=(a=@ (some (add a 2))))
        ~

---
 
###++bind

Bind

```
++  bind                                                ::  argue
  |*  [a=(unit) b=gate]
  ?~  a  ~
  [~ u=(b u.a)]
::
```

---

Applies a function to the value of a unit, producing a unit.

`a`
A unit

`b`
A gate.

        ~zod/try=> (bind ((unit ,@) [~ 97]) ,@t)
        [~ `a`]
        ~zod/try=> =a |=(a=@ (add a 1))
        ~zod/try=> (bind ((unit ,@) [~ 2]) a)
        [~ 3]

---

###++bond

Replace Null


```
++  bond                                                ::  replace
  |*  a=trap
  |*  b=(unit)
  ?~  b  $:a
  u.b
::
```

Replaces an empty unit with the product of a kicked trap. If the unit is not empty, then the original unit is produced.


`a`
A trap.
`b`
A unit.

        ~zod/try=> ((bond |.((bex 100))) (slaw %ud '123'))
        123
        ~zod/try=> ((bond |.((bex 100))) (slaw %ud '12.3'))
        1.267.650.600.228.229.401.496.703.205.376
        XX Better example here; not clear why slaw gate produces null.

---

###++both

Group unit values

```
++  both                                                ::  all the above
  |*  [a=(unit) b=(unit)]
  ?~  a  ~
  ?~  b  ~
  [~ u=[u.a u.b]]
::
```

Produces a unit whose value is a cell of the values of two input units. If either of the two units are empty, `~` is produced. 

    ~zod/try=> (both (some 1) (some %b))
    [~ u=[1 %b]]
    ~zod/try=> (both ~ (some %b))
    ~

`a`
A unit.

`b`
A unit.

---

###++clap

Apply gate to two units

```
++  clap                                                ::  combine
  |*  [a=(unit) b=(unit) c=_|=(^ +<-)]
  ?~  a  b
  ?~  b  a
  [~ u=(c u.a u.b)]
::
```

---

Apply a binary operation which yields a unit to the values of two units.

`a`
A unit.

`b`
A unit.

`c`
A gate that performs a binary operation.

        ~zod/try=> =u ((unit ,@t) [~ 'a'])
        ~zod/try=> =v ((unit ,@t) [~ 'b'])
        ~zod/try=> (clap u v |=([a=@t b=@t] (welp (trip a) (trip b))))
        [~ u="ab"] 
        ~zod/try=> =a ((unit ,@u) [~ 1])
        ~zod/try=> =b ((unit ,@u) [~ 2])
        ~zod/try=> =c |=([a=@ b=@] (add a b))
        ~zod/try=> (clap a b c)
        [~ 3]
      
---

###++drop 

Unit list

```
++  drop                                                ::  enlist
  |*  a=(unit)
  ?~  a  ~
  [i=u.a t=~]
::
```

Produce a list of the unit-value. 

`a`
A unit.

        ~zod/try=> =a ((unit ,@) [~ 97])
        ~zod/try=> (drop a)
        [i=97 t=~] 
        ~zod/try=> =a ((unit ,@) [~])
        ~zod/try=> (drop a)
        ~

---

###++fall

Default unit

```
++  fall                                                ::  default
  |*  [a=(unit) b=*]
  ?~(a b u.a)
::
```

Produces a default value for a unit in cases where the unit is null.

`a`
A unit

`b`
A noun used as the default value.

        ~zod/try=> (fall ~ `a`)
        `a`
        ~zod/try=> (fall [~ u=0] `a`)
        0

---

###++lift

Fmap

```
++  lift                                                ::  lift gate (fmap)
  |*  a=gate                                            ::  flipped
  |*  b=(unit)                                          ::  curried
  (bind b a)                                            ::  bind
::
```

Similar to `fmap` in Haskell: accepts a gate that accepts and produces an unwrapped value, passes it a unit value, and then produces a unit value.

`a`
A gate.

`b`
A unit.

---

###++mate

Choose

```
++  mate                                                ::  choose
  |*  [a=(unit) b=(unit)]
  ?~  b  a
  ?~  a  b
  ?.(=(u.a u.b) ~|('mate' !!) a)
::
```

Accepts two units whose values are expected to be equivalent. If either is empty, then the value of the other is produced. If neither are empty, it asserts that both values are the same and produces that value. If the assertion fails, it crashes with 'mate' in the stack trace.

Accepts two units. If either is empty, the other is produced. If neither is empty, `a` is produced, except for when both units are equivalent, in which case there is a crash with 'mate'.

`a`
A unit.

`b`
A unit.

        ~zod/try=> =a ((unit ,@) [~ 97])
        ~zod/try=> =b ((unit ,@) [~ 97])
        ~zod/try=> (mate a b)
        [~ 97]
        ~zod/try=> =a ((unit ,@) [~ 97])
        ~zod/try=> =b ((unit ,@) [~])
        ~zod/try=> (mate a b)
        [~ 97]
        ~zod/try=> =a ((unit ,@) [~ 97])
        ~zod/try=> =b ((unit ,@) [~ 98])
        ~zod/try=> (mate a b)
        ! 'mate'
        ! exit

---

###++need 

Unwrap

```
++  need                                                ::  demand
  |*  a=(unit)
  ?~  a  !!
  u.a
::
```

Retrieve the value from a unit and crash if the unit is null.

`a`
A unit.

        ~zod/try=> =a ((unit ,[@t @t]) [~ ['a' 'b']])
        ~zod/try=> (need a)
        ['a' 'b']
        ~zod/try=> =a ((unit ,@ud) [~ 17])
        ~zod/try=> (need a)
        17
        ~zod/try=> =a ((unit ,@) [~])
        ~zod/try=> (need a)
        ! exit

---

###++some 

Unify

```
++  some                                                ::  lift (pure)
  |*  a=*
  [~ u=a]
```

Casts any noun to its unit. 

`a`
A noun.

        ~zod/try=> (some [`a` `b`])
        [~ u=[`a` `b`]]
        ~zod/try=> (some &)
        [~ u=%.y]

---

##section 2bB, lists                    

Reverse

###++flop 

```
++  flop                                                ::  reverse
  ~/  %flop
  |*  a=(list)
  =>  .(a (homo a))
  ^+  a
  =+  b=`_a`~
  |-
  ?~  a  b
  $(a t.a, b [i.a b])
::
```

~latdyt-fonsel/try=> =a (limo [1 2 3 ~])
~latdyt-fonsel/try=> (flop a)
~[3 2 1]

###++homo

Homogenize

```
++  homo                                                ::  homogenize
  |*  a=(list)
  ^+  =<  $
    |%  +-  $  ?:(_? ~ [i=(snag 0 a) t=$])
    --
  a
::
```

Homogenizes a lists' type information.

`a`
A list.

        ~zod/try=> lyst
        [i=1 t=[i=97 t=[i=2 t=[i=98 t=[i=[~ u=10] t=~]]]]]
        ~zod/try=> (homo lyst)
        ~[1 97 2 98 [~ u=10]]
        ~zod/try=> =a (limo [1 2 3 ~])
        ~zod/try=> a
        [i=1 t=[i=2 t=[i=3 t=~]]]
        ~zod/try=> (homo a)
        ~[1 2 3]

###++limo 

List Constructor

```
++  limo                                                ::  listify
  |*  a=*
  ^+  =<  $
    |%  +-  $  ?~(a ~ ?:(_? i=-.a t=$ $(a +.a)))
    --
  a
::
```

        ~zod/try=> (limo [1 2 3 ~])
        [i=1 t=[i=2 t=[i=3 t=~]]]
        ~zod/try=> (limo [1 %a 3 ~])
        [i=1 t=[i=97 t=[i=3 t=~]]]
        ~zod/try=> (limo [%a %a 3 ~])
        [i=%a t=[i=%a t=[i=3 t=~]]]
        ~zod/try=> (limo [%a [%a 3] ~])
        [i=%a t=[i=[%a 3] t=~]]

Turns a null-terminated tuple into a list.

`a`
A null-terminated tuple.

        ~zod/try=> (limo [1 2 3 ~])
        [i=1 t=[i=2 t=[i=3 t=~]]]

Produces the atomic length of any list.

        ~zod/try=> (lent (limo [1 2 3 4 ~]))
        4
        ~zod/try=> (lent (limo [1 'a' 2 'b' (some 10) ~]))
        5

---

###++levy

"or" to list

```
++  levy
  ~/  %levy                                             ::  all of
  |*  [a=(list) b=_|=(p=* .?(p))]
  |-  ^-  ?
  ?~  a  &
  ?.  (b i.a)  |
  $(a t.a)
::
```

Produces the Boolean "or" to the result of every element in list `a` with gate `b`.

        ~zod/try=> =a |=(a=@ (gte a 1))
        ~zod/try=> (lien (limo [0 1 2 1 ~]) a)
        %.y
        ~zod/try=> =a |=(a=@ (gte a 3))
        ~zod/try=> (lien (limo [0 1 2 1 ~]) a)
        %.n

---

###++murn

Maybe transform

```
++  murn                                                ::  maybe transform
  |*  [a=(list) b=$+(* (unit))]
  |-
  ?~  a  ~
  =+  c=(b i.a)
  ?~  c
    $(a t.a)
  [i=u.c t=$(a t.a)]
::
```

XX Needs a description and examples

###++reel

Right fold

```
++  reel                                                ::  right fold  
  ~/  %reel
  |*  [a=(list) b=_|=([* *] +<+)]
  |-  ^+  +<+.b
  ?~  a
    +<+.b
  (b i.a $(a t.a))
```

Right fold: moves right to left, recursively slamming a binary gate with an 
element from the list and an accumulator, producing the final value of the
accumulator.

        ~zod/try=> =sum =|([p=@ q=@] |.((add p q)))
        ~zod/try=> (reel (limo [1 2 3 4 5 ~]) sum)
        15
        ~zod/try=> =a =|([p=@ q=@] |.((sub p q)))
        ~zod/try=> (reel (limo [6 3 1 ~]) a)
        4
        ~zod/try=> (reel (limo [3 6 1 ~]) a)
        ! subtract-underflow
        ! exit

---

###++roll

Left fold

```
++  roll                                                ::  left fold
  ~/  %roll
  |*  [a=(list) b=_|=([* *] +<+)]
  |-  ^+  +<+.b
  ?~  a
    +<+.b
  $(a t.a, b b(+<+ (b i.a +<+.b)))
::
```

Left fold: moves left to right, recursively slamming a binary gate with an 
element from the list and an accumulator, producing the final value of the
accumulator.

---

###++skim

Suffix

```
++  skim                                                ::  only
  ~/  %skim
  |*  [a=(list) b=_|=(p=* .?(p))]
  |-
  ^+  a
  ?~  a  ~
  ?:((b i.a) [i.a $(a t.a)] $(a t.a))
::
```

Accepts an atom `a` and list `b`, producing the last `a` elements from the back of the list.

        ~zod/try=> (slag 2 (limo [1 2 3 4 ~]))
        [i=3 t=[i=4 t=~]]

---

###++snag 

CharAt

```
++  snag                                                ::  index
  ~/  %snag
  |*  [a=@ b=(list)]
  |-
  ?~  b
    ~|('snag-fail' !!)
  ?:  =(0 a)  i.b
  $(b t.b, a (dec a))
::
```

Accepts an atom and a list, producing the element at the index of the atom in 
the list and failing if the list is null.

    ~zod/try=> (snag 2 "asdf")
    ~~d
    ~zod/try=> (snag 0 `(list ,@ud)`~[1 2 3 4])
    1

---

###++sort

Quicksort

```
++  sort                                                ::  quicksort
  ~/  %sort
  |*  [a=(list) b=$+([* *] ?)]
  =>  .(a ^.(homo a))
  |-  ^+  a
  ?~  a  ~
  %+  weld
    $(a (skim t.a |=(c=_i.a (b c i.a))))
  ^+  t.a
  [i.a $(a (skim t.a |=(c=_i.a !(b c i.a))))]
::
```

Quicksort: accepts a list and a gate with a sample which compares two nouns and produces a loobean.  'sort' then produces a 
list of the elements of 'a' sorted according to 'b'.

        ~zod/try=> =a =|([p=@ q=@] |.((gth p q)))
        ~zod/try=> (sort (limo [0 1 2 3 ~]) a)
        ~[3 2 1 0]

---

###++swag

Infix

```
++  swag                                                ::  infix
  |*  [[a=@ b=@] c=(list)]
  (scag b (slag a c))
::
```

Similar to `substr` in Javascript: extracts a string infix, beginning at inclusive index `a`, producing `b` number of characters.

    ~zod/try=> (swag [2 5] "roly poly")
    "ly po"

---

###++turn

Gate to list

```
++  turn                                                ::  transform
  ~/  %turn
  |*  [a=(list) b=_,*]
  |-
  ?~  a  ~
  [i=(b i.a) t=$(a t.a)]
::
```

Accepts a list `a` and a gate `b`. Produces the list with the gate applied to each element of the original list.

        ~zod/try=> (turn (limo [104 111 111 110 ~]) ,@t)
        <|h o o n|>

###++weld 

Concatenate

```
++  weld                                                ::  concatenate
  ~/  %weld
  |*  [a=(list) b=(list)]
  =>  .(a ^.(homo a), b ^.(homo b))
  |-  ^+  b
  ?~  a  b
  [i.a $(a t.a)]
::
```

Concatenate two lists without losing their type information to homogenization.
Produces a tape when passed two tapes.

        ~zod/try=> (welp "foo" "bar")
        "foobar"

---

###++wild

XXDELETE

```
++  wild                                                ::  concatenate
  |*  [a=(list) b=(list)]
  =>  .(a ^.(homo a), b ^.(homo b))
  |-
  ?~  a  b
  [i=i.a $(a t.a)]
::
```

Concatenates two lists, homogenizing their types individually.

    ~zod/try=> (wild (limo ~[1 2 3]) (limo [4]~))
    ~[1 2 3 4]
    ~zod/try=> (wild (limo 60 61 62 ~) (limo %a %b %c ~))
    [i=60 [i=61 [i=62 ~[%a %b %c]]]]
    ~zod/try=> (weld (limo 60 61 62 ~) (limo %a %b %c ~))
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[10.000 15].[10.016 57]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[10.001 15].[10.016 57]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[10.002 15].[10.016 57]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[10.004 15].[10.016 57]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[10.006 15].[10.016 57]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[10.006 29].[10.006 44]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[10.056 3].[10.061 13]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[10.058 3].[10.061 13]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[10.059 3].[10.061 13]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[10.060 5].[10.060 47]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[9.826 7].[9.844 35]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[9.827 7].[9.844 35]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[9.827 11].[9.838 13]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[9.828 11].[9.838 13]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[9.829 13].[9.831 47]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[9.830 13].[9.831 47]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[9.706 7].[9.712 25]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[9.707 7].[9.712 25]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[9.708 7].[9.712 25]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[9.712 7].[9.712 25]>
    ! /~zod/arvo/~2014.10.2..22.58.23..5af9/hoon/:<[9.712 8].[9.712 25]>
    ! exit


---

###++zing

Cons

```
++  zing                                                ::  promote
  =|  *
  |%
  +-  $
    ?~  +<
      +<
    (welp +<- $(+< +<+))
  --
```

Turns a list of lists into a single list by promoting the elements of each sublist into the higher.

        ~zod/try=> (zing (limo [(limo ['a' 'b' 'c' ~]) (limo ['e' 'f' 'g' ~]) (limo ['h' 'i' 'j' ~]) ~]))
        ~['a' 'b' 'c' 'e' 'f' 'g' 'h' 'i' 'j']
        ~zod/try=> (zing (limo [(limo [1 'a' 2 'b' ~]) (limo [3 'c' 4 'd' ~]) ~]))
        ~[1 97 2 98 3 99 4 100]


