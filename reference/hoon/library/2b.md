chapter 2b, basic containers

Section 2bA, units                    

###++biff 

```
++  biff                                                ::  apply
  |*  [a=(unit) b=$+(* (unit))]
  ?~  a  ~
  (b u.a)
::
```


Apply a function which produces a unit to the value of a unit

####Examples

        ~zod/try=> (biff (some 5) |=(a=@ (some (add a 2))))
        [~ u=7]
        ~zod/try=> (biff ~ |=(a=@ (some (add a 2))))
        ~
 
###++bind 

```
++  bind                                                ::  argue
  |*  [a=(unit) b=gate]
  ?~  a  ~
  [~ u=(b u.a)]
::
```


Apply a function to the value of a unit.

####Examples

        ~zod/try=> (bind ((unit ,@) [~ 97]) ,@t)
        [~ `a`]
        ~zod/try=> =a |=(a=@ (add a 1))
        ~zod/try=> (bind ((unit ,@) [~ 2]) a)
        [~ 3]

###++bond

```
++  bond                                                ::  replace
  |*  a=trap
  |*  b=(unit)
  ?~  b  $:a
  u.b
::
```

        
Evaluate trap `a` if `b` is null 

####Examples

        ??

###++both

```
++  both                                                ::  all the above
  |*  [a=(unit) b=(unit)]
  ?~  a  ~
  ?~  b  ~
  [~ u=[u.a u.b]]
::
```



####Examples

        ??


###++clap 

```
++  clap                                                ::  combine
  |*  [a=(unit) b=(unit) c=_|=(^ +<-)]
  ?~  a  b
  ?~  b  a
  [~ u=(c u.a u.b)]
::
```


Apply a binary operation which yields a unit to the values of two units

####Examples

        ~zod/try=> =u ((unit ,@t) [~ 'a'])
        ~zod/try=> =v ((unit ,@t) [~ 'b'])
        ~zod/try=> (clap u v |=([a=@t b=@t] (welp (trip a) (trip b))))
        [~ u="ab"] 
        ~zod/try=> =a ((unit ,@u) [~ 1])
        ~zod/try=> =b ((unit ,@u) [~ 2])
        ~zod/try=> =c |=([a=@ b=@] (add a b))
        ~zod/try=> (clap a b c)
        [~ 3]

###++drop 

```
++  drop                                                ::  enlist
  |*  a=(unit)
  ?~  a  ~
  [i=u.a t=~]
::
```


Produce a list of the unit-value 

####Examples

        ~zod/try=> =a ((unit ,@) [~ 97])
        ~zod/try=> (drop a)
        [i=97 t=~] 
        ~zod/try=> =a ((unit ,@) [~])
        ~zod/try=> (drop a)
        ~

###++fall 

```
++  fall                                                ::  default
  |*  [a=(unit) b=*]
  ?~(a b u.a)
::
```


A default value `b` for the unit `a` when `a` is null

####Examples

        ~zod/try=> (fall ~ `a`)
        `a`
        ~zod/try=> (fall [~ u=0] `a`)
        0

###++lift

```
++  lift                                                ::  lift gate (fmap)
  |*  a=gate                                            ::  flipped
  |*  b=(unit)                                          ::  curried
  (bind b a)                                            ::  bind
::
```


Fmap; Accept a gate that accepts and produces an unwrapped value and pass it a
unit value, then produce a unit value.

##+mate 

Produce the unit `a` or `b` which is not null and crashes with error
"mate" unless `a` and `b` are equal.

####Examples

        ~zod/try=> =a ((unit ,@) [~ 97])
        ~zod/try=> =b ((unit ,@) [~ 97])
        ~zod/try=> (mate a b)
        [~ 97]
        ~zod/try=> =a ((unit ,@) [~ 97])
        ~zod/try=> =b ((unit ,@) [~])
        ~zod/try=> (mate a b)
        [~ 97]
        ~zod/try=> =a ((unit ,@) [~ 97])
        ~zod/try=> =b ((unit ,@) [~ 98])
        ~zod/try=> (mate a b)
        ! 'mate'
        ! exit

###++need 

```
++  need                                                ::  demand
  |*  a=(unit)
  ?~  a  !!
  u.a
::
```


Retrieve the value from a unit and crash if the unit is null.

####Examples

        ~zod/try=> =a ((unit ,[@t @t]) [~ ['a' 'b']])
        ~zod/try=> (need a)
        ['a' 'b']
        ~zod/try=> =a ((unit ,@ud) [~ 17])
        ~zod/try=> (need a)
        17
        ~zod/try=> =a ((unit ,@) [~])
        ~zod/try=> (need a)
        ! exit

###++some 

```
++  some                                                ::  lift (pure)
  |*  a=*
  [~ u=a]
```


Casts any noun `a` to its unit, [~ a].

####Examples

        ~zod/try=> (some [`a` `b`])
        [~ u=[`a` `b`]]
        ~zod/try=> (some &)
        [~ u=%.y]

section 2bB, lists                    

##++flop 

```
++  flop                                                ::  reverse
  ~/  %flop
  |*  a=(list)
  =>  .(a (homo a))
  ^+  a
  =+  b=`_a`~
  |-
  ?~  a  b
  $(a t.a, b [i.a b])
::
```


Homogenizes a lists' type information.

####Examples

        ~zod/try=> lyst
        [i=1 t=[i=97 t=[i=2 t=[i=98 t=[i=[~ u=10] t=~]]]]]
        ~zod/try=> (homo lyst)
        ~[1 97 2 98 [~ u=10]]
        ~zod/try=> =a (limo [1 2 3 ~])
        ~zod/try=> a
        [i=1 t=[i=2 t=[i=3 t=~]]]
        ~zod/try=> (homo a)
        ~[1 2 3]

###++limo 

```
++  limo                                                ::  listify
  |*  a=*
  ^+  =<  $
    |%  +-  $  ?~(a ~ ?:(_? [i=-.a t=$] $(a +.a)))
    --
  a
::
```


Produces the atomic length of any list.

####Examples
:
        ~zod/try=> (lent (limo [1 2 3 4 ~]))
        4
        ~zod/try=> (lent (limo [1 'a' 2 'b' (some 10) ~]))
        5

###++levy

```
++  levy
  ~/  %levy                                             ::  all of
  |*  [a=(list) b=_|=(p=* .?(p))]
  |-  ^-  ?
  ?~  a  &
  ?.  (b i.a)  |
  $(a t.a)
::
```


Is the slam of any element in list `a` to `b` true? (Boolean 'or')

####Examples

        ~zod/try=> =a |=(a=@ (gte a 1))
        ~zod/try=> (lien (limo [0 1 2 1 ~]) a)
        %.y
        ~zod/try=> =a |=(a=@ (gte a 3))
        ~zod/try=> (lien (limo [0 1 2 1 ~]) a)
        %.n

###++murn

```
++  murn                                                ::  maybe transform
  |*  [a=(list) b=$+(* (unit))]
  |-
  ?~  a  ~
  =+  c=(b i.a)
  ?~  c
    $(a t.a)
  [i=u.c t=$(a t.a)]
::
```


Right fold - Move right to left recursively slamming a binary gate with an element from the list and an accumulator,
        producing the final value of the accumulator.

####Examples

        ~zod/try=> =sum =|([p=@ q=@] |.((add p q)))
        ~zod/try=> (reel (limo [1 2 3 4 5 ~]) sum)
        15
        ~zod/try=> =a =|([p=@ q=@] |.((sub p q)))
        ~zod/try=> (reel (limo [6 3 1 ~]) a)
        4
        ~zod/try=> (reel (limo [3 6 1 ~]) a)
        ! subtract-underflow
        ! exit

###++roll

```
++  roll                                                ::  left fold
  ~/  %roll
  |*  [a=(list) b=_|=([* *] +<+)]
  |-  ^+  +<+.b
  ?~  a
    +<+.b
  $(a t.a, b b(+<+ (b i.a +<+.b)))
::
```



```
++  skim                                                ::  only
  ~/  %skim
  |*  [a=(list) b=_|=(p=* .?(p))]
  |-
  ^+  a
  ?~  a  ~
  ?:((b i.a) [i.a $(a t.a)] $(a t.a))
::
```


Accepts an atom `a` and list `b`, producing the last `a` elements from the back of the list.

####Examples
:
        [i=2 t=[i=3 t=~]] 
        ---
        ~zod/try=> (slag 2 (limo [1 2 3 4 ~]))
        [i=3 t=[i=4 t=~]]

###++snag 

```
++  snag                                                ::  index
  ~/  %snag
  |*  [a=@ b=(list)]
  |-
  ?~  b
    ~|('snag-fail' !!)
  ?:  =(0 a)  i.b
  $(b t.b, a (dec a))
::
```

Accepts an atom and a list, producing the element at the index of the atom in 
the list and failing if the list is null.

###++sort


Accepts a list `a` and a gate `b` with a sample which accepts two nouns and produces a loobean.  'sort' then produces a 
list of the elements of 'a' sorted according to 'b'.

####Examples
:
        ~zod/try=> =a =|([p=@ q=@] |.((gth p q)))
        ~zod/try=> (sort (limo [0 1 2 3 ~]) a)
        ~[3 2 1 0]

###++swag

```
++  swag                                                ::  infix
  |*  [[a=@ b=@] c=(list)]
  (scag b (slag a c))
::
```


Accepts a list `a` and a gate `b`. Produces the list with the gate applied to each element of the original list.

####Examples

        ~zod/try=> (turn (limo [104 111 111 110 ~]) ,@t)
        <|h o o n|>

###++weld 

```
++  weld                                                ::  concatenate
  ~/  %weld
  |*  [a=(list) b=(list)]
  =>  .(a ^.(homo a), b ^.(homo b))
  |-  ^+  b
  ?~  a  b
  [i.a $(a t.a)]
::
```


Concatenate two lists without losing their type information to homogenization.
Produces a tape when passed two tapes.

####Examples
:
        ~zod/try=> (welp "foo" "bar")
        "foobar"

###++wild

```
++  wild                                                ::  concatenate
  |*  [a=(list) b=(list)]
  =>  .(a ^.(homo a), b ^.(homo b))
  |-
  ?~  a  b
  [i=i.a $(a t.a)]
::
```


Turns a list of lists into a single list by promoting the elements of each sublist into the higher.

####Examples
:
        ~zod/try=> (zing (limo [(limo ['a' 'b' 'c' ~]) (limo ['e' 'f' 'g' ~]) (limo ['h' 'i' 'j' ~]) ~]))
        ~['a' 'b' 'c' 'e' 'f' 'g' 'h' 'i' 'j']
        ~zod/try=> (zing (limo [(limo [1 'a' 2 'b' ~]) (limo [3 'c' 4 'd' ~]) ~]))
        ~[1 97 2 98 3 99 4 100]


